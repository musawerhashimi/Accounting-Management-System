
########## MODEL ############

class Product(BaseModel):
    """Master product catalog with basic info and default pricing"""
    
    name = models.CharField(max_length=200)
    barcode = models.CharField(
        max_length=50, 
        unique=True, 
        blank=True, 
        null=True,
        help_text="Unique product identifier (can be scanned)"
    )
    sku = models.CharField(
        max_length=50, 
        unique=True,
        help_text="Stock Keeping Unit (internal code)"
    )
    category = models.ForeignKey(
        Category, 
        on_delete=models.CASCADE, 
        related_name='products'
    )
    unit = models.ForeignKey(
        'core.Unit', 
        on_delete=models.PROTECT, 
        related_name='products',
        help_text="Default measurement unit"
    )
    description = models.TextField(blank=True)
    cost_price = models.DecimalField(
        max_digits=15, 
        decimal_places=2,
        validators=[MinValueValidator(Decimal('0.00'))],
        help_text="How much we pay to buy this product"
    )
    selling_price = models.DecimalField(
        max_digits=15, 
        decimal_places=2,
        validators=[MinValueValidator(Decimal('0.00'))],
        help_text="Default selling price"
    )
    price_currency = models.ForeignKey(
        'core.Currency', 
        on_delete=models.PROTECT, 
        related_name='products',
        help_text="Currency for the prices above"
    )
    reorder_level = models.PositiveIntegerField(
        default=0,
        help_text="Minimum stock before reordering"
    )
    is_active = models.BooleanField(default=True)

    class Meta:
        db_table = 'products'
        ordering = ['name']
        indexes = [
            models.Index(fields=['barcode']),
            models.Index(fields=['sku']),
            models.Index(fields=['category', 'is_active']),
        ]

    def __str__(self):
        return f"{self.name} ({self.sku})"

    def clean(self):
        from django.core.exceptions import ValidationError
        
        # Product can only be active if its category is active
        if self.is_active and self.category and not self.category.is_active:
            raise ValidationError("Product cannot be active if its category is inactive")
        
        # Selling price should be higher than cost price (warning, not error)
        if self.selling_price <= self.cost_price:
            # This could be a warning in admin, but not blocking
            pass

    @property
    def profit_margin(self):
        """Calculate profit margin percentage"""
        if self.cost_price == 0:
            return 0
        return ((self.selling_price - self.cost_price) / self.cost_price) * 100

    @property
    def profit_amount(self):
        """Calculate profit amount per unit"""
        return self.selling_price - self.cost_price

    @property
    def department(self):
        """Get department through category"""
        return self.category.department

    def update_price(self, new_cost_price=None, new_selling_price=None, new_currency=None, user=None):
        """Update product price and create price history record"""
        from django.utils import timezone
        
        # End current price history
        current_price = self.price_history.filter(end_date__isnull=True).first()
        if current_price:
            current_price.end_date = timezone.now().date()
            current_price.save()
        
        # Create new price history
        
        if new_currency:
            from core.models import CurrencyRate
            latest_rate = CurrencyRate.get_latest_rate(self.price_currency, new_currency)
            if not new_cost_price:
                new_cost_price = latest_rate.convert_amount(self.cost_price)
            if not new_selling_price:
                new_selling_price = latest_rate.convert_amount(self.selling_price)

        ProductPrice.objects.create(
            product=self,
            cost_price=new_cost_price or self.cost_price,
            selling_price=new_selling_price or self.selling_price,
            currency=new_currency or self.price_currency,
            effective_date=timezone.now().date(),
            created_by_user=user
        )
        
        # Update current prices
        if new_cost_price is not None:
            self.cost_price = new_cost_price
        if new_selling_price is not None:
            self.selling_price = new_selling_price
        if new_currency is not None:
            self.price_currency = new_currency
            
        self.save()


########## SERIALIZER ############

class ProductSerializer(serializers.ModelSerializer):
    """Serializer for Product model"""
    category_name = serializers.CharField(source='category.name', read_only=True)
    department_name = serializers.CharField(source='category.department.name', read_only=True)
    unit_name = serializers.CharField(source='unit.name', read_only=True)
    unit_abbreviation = serializers.CharField(source='unit.abbreviation', read_only=True)
    currency_code = serializers.CharField(source='price_currency.code', read_only=True)
    
    # Inventory information
    total_stock = serializers.SerializerMethodField()
    available_stock = serializers.SerializerMethodField()
    locations_count = serializers.SerializerMethodField()
    
    # Pricing information
    current_prices = serializers.SerializerMethodField()
    profit_margin = serializers.SerializerMethodField()
    
    # Sales metrics
    total_sold = serializers.SerializerMethodField()
    revenue_generated = serializers.SerializerMethodField()
    
    class Meta:
        model = Product
        fields = [
            'id', 'name', 'barcode', 'sku', 'category', 'category_name', 
            'department_name', 'unit', 'unit_name', 'unit_abbreviation',
            'description', 'cost_price', 'selling_price', 'price_currency',
            'currency_code', 'reorder_level', 'is_active',
            'total_stock', 'available_stock', 'locations_count',
            'current_prices', 'profit_margin', 'total_sold', 'revenue_generated',
            'created_at', 'updated_at'
        ]
        read_only_fields = ['created_at', 'updated_at']
    


    def validate_barcode(self, value):
        """Validate barcode uniqueness"""
        if value:
            existing = Product.objects.filter(
                barcode=value,
                deleted_at__isnull=True
            ).exclude(id=getattr(self.instance, 'id', None))
            
            if existing.exists():
                raise serializers.ValidationError("Product with this barcode already exists")
        return value
    
    def validate_sku(self, value):
        """Validate SKU uniqueness"""
        if value:
            existing = Product.objects.filter(
                sku=value,
                deleted_at__isnull=True
            ).exclude(id=getattr(self.instance, 'id', None))
            
            if existing.exists():
                raise serializers.ValidationError("Product with this SKU already exists")
        return value
    
    def validate(self, data):
        """Custom validation for product pricing"""
        cost_price = data.get('cost_price', 0)
        selling_price = data.get('selling_price', 0)
        
        if cost_price and cost_price < 0:
            raise serializers.ValidationError("Cost price cannot be negative")
        
        if selling_price and selling_price < 0:
            raise serializers.ValidationError("Selling price cannot be negative")
        
        if cost_price and selling_price and selling_price < cost_price:
            raise serializers.ValidationError("Selling price should not be less than cost price")
        
        return data

    # Other Features ....


########## VIEWSET ############


class ProductViewSet(BasePermissionMixin, viewsets.ModelViewSet):
    """ViewSet for managing products with pagination"""
    queryset = Product.objects.select_related(
        'category', 'category__department', 'unit', 'price_currency'
    ).filter(deleted_at__isnull=True)
    serializer_class = ProductSerializer
    pagination_class = StandardResultsSetPagination
    filter_backends = [DjangoFilterBackend, SearchFilter, OrderingFilter]
    filterset_fields = [
        'category', 'category__department', 'unit', 'is_active', 
        'price_currency'
    ]
    search_fields = ['name', 'barcode', 'sku', 'description']
    ordering_fields = [
        'name', 'cost_price', 'selling_price', 'created_at', 
        'category__name', 'reorder_level'
    ]
    ordering = ['name']
    
    def get_permissions(self):
        if self.action in ['list', 'retrieve']:
            permission_classes = [permissions.IsAuthenticated]
        else:
            permission_classes = [permissions.IsAuthenticated]
        return [permission() for permission in permission_classes]
    
    def check_permissions(self, request):
        super().check_permissions(request)
        if not self.has_module_permission(request, 'products'):
            self.permission_denied(request)
    
    def get_serializer_class(self):
        """Use lightweight serializer for list view"""
        if self.action == 'list':
            return ProductListSerializer
        return ProductSerializer
    
    def perform_destroy(self, instance):
        """Soft delete product"""
        instance.deleted_at = timezone.now()
        instance.save()
    
    @action(detail=False, methods=['get'])
    def low_stock(self, request):
        """Get products with low stock"""
        from inventory.models import Inventory
        
        low_stock_products = []
        products = self.queryset.filter(is_active=True)
        
        for product in products:
            total_stock = Inventory.objects.filter(
                product=product
            ).aggregate(total=Sum('quantity_on_hand'))['total'] or 0
            
            if total_stock <= product.reorder_level:
                low_stock_products.append(product)
        
        page = self.paginate_queryset(low_stock_products)
        if page is not None:
            serializer = ProductListSerializer(page, many=True)
            return self.get_paginated_response(serializer.data)
        
        serializer = ProductListSerializer(low_stock_products, many=True)
        return Response(serializer.data)
    
    @action(detail=False, methods=['get'])
    def search_by_barcode(self, request):
        """Search product by barcode"""
        barcode = request.query_params.get('barcode')
        if not barcode:
            return Response(
                {'error': 'barcode parameter is required'},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        try:
            product = self.queryset.get(barcode=barcode, is_active=True)
            serializer = self.get_serializer(product)
            return Response(serializer.data)
        except Product.DoesNotExist:
            return Response(
                {'error': 'Product not found'},
                status=status.HTTP_404_NOT_FOUND
            )
    
    @action(detail=True, methods=['post'])
    def update_price(self, request, pk=None):
        """Update product price with history tracking"""
        product = self.get_object()
        
        # End current price if exists
        current_prices = ProductPrice.objects.filter(
            product=product,
            end_date__isnull=True
        )
        
        today = timezone.now().date()
        for price in current_prices:
            price.end_date = today
            price.save()
        
        # Create new price record
        price_data = {
            'product': product.id,
            'cost_price': request.data.get('cost_price', product.cost_price),
            'selling_price': request.data.get('selling_price', product.selling_price),
            'currency': request.data.get('currency', product.price_currency.id),
            'effective_date': request.data.get('effective_date', today),
            'created_by_user': request.user.id
        }
        
        price_serializer = ProductPriceSerializer(data=price_data)
        if price_serializer.is_valid():
            price_serializer.save()
            
            # Update product's current prices
            product.cost_price = price_data['cost_price']
            product.selling_price = price_data['selling_price']
            product.save()
            
            return Response(price_serializer.data, status=status.HTTP_201_CREATED)
        
        return Response(price_serializer.errors, status=status.HTTP_400_BAD_REQUEST)
    
    @action(detail=False, methods=['get'])
    def analytics(self, request):
        """Get product analytics"""
        analytics = {
            'total_products': self.queryset.filter(is_active=True).count(),
            'total_categories': Category.objects.filter(is_active=True, deleted_at__isnull=True).count(),
            'total_departments': Department.objects.filter(is_active=True, deleted_at__isnull=True).count(),
            'avg_selling_price': self.queryset.filter(
                is_active=True, selling_price__gt=0
            ).aggregate(avg=Avg('selling_price'))['avg'] or 0,
            'price_range': {
                'min': self.queryset.filter(
                    is_active=True, selling_price__gt=0
                ).aggregate(min=Min('selling_price'))['min'] or 0,
                'max': self.queryset.filter(
                    is_active=True, selling_price__gt=0
                ).aggregate(max=Max('selling_price'))['max'] or 0
            }
        }
        
        return Response(analytics)
